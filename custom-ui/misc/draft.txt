Comment nommer le principe de développement qu'outille ReflectionUI-CustomUI ?
Pour cela on pourrait s'inspirer de principes similaires déjà bien identifiés.

L'ORM s'en approche dans le sens où il permet de produire automatiquement la
tuyauterie de la persistance (adapter selon le DDD), puis de la personnaliser
avec la contrainte de s'interfacer avec un schéma de BD souvent déjà existant.   
C'est cette contrainte d'interfaçage avec 1 schéma de BD qui fait qu'on utilise le
terme "mapping", car il y a en effet un modèle source (les classes) et un modèle
cible (la BD) qui diffèrent par nature. Avec ReflectionUI-CustomUI il n'y a pas vraiment de 
modèle cible, hormis d'éventuelles maquettes très peu contraignantes qui permettent 
juste d'orienter les développements. On ne peut donc pas parler de "mapping", juste
d'adaptation technique et de personnalisation. A noter aussi que contrairement
à l'UI, la persistance que facilite l'ORM est plus un moyen qu'une fin, ce qui permet 
(théoriquement) de négligemment limiter voire supprimer dans des cas simples la 
personnalisation. Hors, avec ReflectionUI-CustomUI la personnalisation est capitale.
Il faut en tenir compte dans la formulation. On pourrait alors parler de "développement
orienté configuration/personnalisation combinatoire" ou "NoCode" pour le front ou l'UI/UX de 
façon générale. 

Mais ça ne ferait pas ressortir le fait que le développeur aura 
insidieusement tendance à refactorer le modèle de classes de son domaine pour le
faire ressembler à l'UI finale qu'il souhaite obtenir. En effet ReflectionUI-CustomUI
pousse à ça car bien que les options de personnalisation offrent beaucoup de 
possibilités, ces dernières ne sont pas illimitées, et on a plutôt intérêt à
avoir un modèle de classes qui requerra le moins de personnalisations possibles
pour arrviver au résultat graphique voulu. Le développeur aura aussi la possibilité
d'émuler directement dans les classes métiers, des comportements de composants
graphiques complexes et il ne s'en privera pas. Typiquement un lecteur video pourra être émulé graĉe à un
object ayant simplement une propriété "image courante" affichéé avec rafraîchissement
péridique, et des méthodes de contrôle de la lecture (lancement, arrêt, avance rapide, etc).
Il est également à noter qu'une forme de navigation dans l'UI pourra être émulée et
contrôlée depuis le modèle/controlleur directement, plutôt que dans la vue. En fait on
pourrait litérallement émuler un navigateur Internet.
La façon d'aborder le développement d'une UI changera donc sensiblement, et des modèles de
classes graphiques mais abstraits (indépendants de tout framework graphique) apparaîtront.
Toutes ces classes dont la forme va se rapprocher de l'UI peuvent amener à parler de 
"modélisation/développement orienté End-User-Interface".

