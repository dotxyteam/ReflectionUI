DESCRIPTION
-----------
The aim of ReflectionUI is to allow to build appropriate UIs from objects
without coding (or with very few coding=).


DEVELOPER GUIDE
---------------
Since there is not enough information in objects to build a user friendly UI, 
enrichment and customization are then needed.
To achieve this goal, 2 main layers have been created:
- IInfo layer: an abstract GUI model
- Rendering layer: GUI elements layer

	IInfo layer
	-----------
	It defines an abstract GUI model that is an extended subset of the object 
	oriented paradigm: Classes are ITypeInfo objects, field are IFielInfo objects, etc.
	This model is then mainly composed of interfaces + default implementations.
	Here are the important elements:

		IFieldInfo interface
		--------------------
		This interface represents a field in the object oriented paradigm.  It then allows
		to define how a field should be represented. By default the field representation
		will be based on its type.

		IMethodInfo interface
		---------------------
		This interface represents a method in the object oriented paradigm.  It then allows
		to define how the method representation should behave. By default the method representation
		is an action button that would require parameters values and display the return value
		in a child dialog.

		ITypeInfo interface
		-------------------
		This interface represents a class in the object oriented paradigm.  It then allows
		to define how an object UI of a given class should look like and behave.
		It mainly provides UI informations about fields and methods.
		2 important interfaces are derived from ITypeInfo:

			IListTypeInfo interface
			-----------------------
			This interface allows to describe list-like objects. Various specificities are
			handled like ordering, hierarchy (trees), columns, etc. By default as much information
			as possible is extracted from the standard list-like classes (arrays, collections).
			Hierarchical and tabular features are described by the following types:

				IListStructuralInfo interface
				-----------------------------
				This is the main class describing the hierarchical and tabular structure bound to
				a IListTypeInfo instance. 

				ItemPosition class
				------------------
				This class defines a location and a path to an element in a hierarchical list (or a tree).
				The path is actually the set of informations (field value access infos, list item access infos)
				needed to retrieve or update the value held by a node. Note that the ItemPosition will also 
				allow to check if a node is read-only, its value return mode (reference or copy), etc.
				Typically an ItemPosition will have ancestor ItemPositions allowing to access all the 
				ancestor nodes of the current node.
				Remark: the ItemPosition works in conjunction with the IFieldInfo or IMethodInfo it is associated 
				with. It retrieves the node value from the value returned by the I*Info and updates the value
				that should then be committed by the I*Info.  

				IColumnInfo interface
				---------------------
				This interface allows to enrich the abstract UI model of list-like objects by
				providing multiple user-friendly (organized and formatted) views of list items.

				
			IEnumerationTypeInfo interface
			------------------------------ 
			This interface allows to define objects as being enumeration items. By default only 
			enum types are interpreted as IEnumerationTypeInfo instances.

		ReflectionUI class
		------------------
		This is the class that will build the default implementations
		of IInfo interfaces from objects. Note that it is possible to build implementations
		from other sources such as databases, etc. These default implementations will
		usually need to be customized since there is not enough informations in objects
		to build a user friendly UI.

		InfoProxyFactory class
		----------------------
		This class helps to build proxies of IInfo interfaces in order to customize the 
		default implementations.


	Rendering layer
	---------------
	This is the layer of the GUI elements that are created according the
	supplied IInfo instances. This layer is itself divided into the
	following components:

		Forms
		-----
		Every UI generated by this library is actually a form. This is the main
		GUI element. Forms are therefore bound to a windowing toolkit.

		Controls
		--------
		Each form is composed of field and method controls. Some
		field controls can contain sub forms so that any complex UI structure
		can be generated. Controls are therefore bound to a windowing toolkit.

		Control place holders
		--------------------
		Controls are not directly integrated in forms. They are contained in
		place holders: instances of FieldControlPlaceHolder & MethodControlPlaceHolder.
		The place holders can provide basic control features that will ease the development
		of new controls. Eg: refreshing, error display, undo management strategy, etc.
		Controls can take control of these features by implementing the IAdvancedFieldControl
		interface. Place holders will also handle common features like busy indication,
		update synchronization and delaying, etc.

		Control data layer
		------------------
		This layer contains mainly these elements: IFieldControlData & IMethodControlData.
		These interfaces represent the minimum set of informations needed by the controls
		to achieve their work (how to get/set a value, field caption, etc).These interfaces
		implementations will then act as a glue between the controls and the IInfo instances.
		These control data interfaces were separated from their IInfo counterparts to
		simplify the development of new controls. Note that this layer is not bound to
		any windowing toolkit.

		ModificationStack class
		-----------------------
		This class provides a feature that is common in GUIs: undo management.   
		Note that this class relies on the control data layer and therefore is not bound to any 
		windowing toolkit.

		Renderers
		---------
		These are some of the main components of this library. For now only one renderer
		is available: SwingRenderer. A renderer is actually a factory of GUI elements.
		It will then create control data instances, controls, forms, ModificationStack objects
		and glue them all together to provide a working UI.

DEBIAN INTEGRATION
------------------
Build commands:
	export DEBFULLNAME="OTK Software"
	export DEBEMAIL="dotxyteam@yahoo.fr"
	
	mh_make
	
	export VERSION=`cat debian/changelog | grep UNRELEASED |  grep -P '\d+(\.\d+)+' -o`
	export MAVEN_VERSION=`cat pom.xml | grep -A10 "<project " | grep "<version>" |  grep -P '\d+(\.\d+)+' -o`
	if [ "$VERSION" == "$MAVEN_VERSION" ]; then echo "Current version=$VERSION"; else echo "---- WARNING: Version mismatch: DEBIAN=$VERSION and MAVEN=$MAVEN_VERSION ----"; fi
	
	echo 'tar cfz ../reflection-ui_'$VERSION'.orig.tar.gz src *.xml *.txt' > debian/orig-tar.sh; chmod +x debian/orig-tar.sh; debian/orig-tar.sh
	echo 'extend-diff-ignore = "(debian|tmp|tools|\.classpath|\.settings|\.project)"' > debian/source/options 
	
	cp pom.xml pom.beforeDebianBuild.xml;\
	BUILD_DIR="$HOME/tmp/reflection-ui";\
	rm -rf "$BUILD_DIR";\
	mkdir "$BUILD_DIR";\
	mv ../reflection-ui_$VERSION.orig.tar.gz "$BUILD_DIR/..";\
	cp -r debian "$BUILD_DIR";\
	cd "$BUILD_DIR";\
	tar xfz ../reflection-ui_$VERSION.orig.tar.gz;\
	debuild;\
	cd -;\
	cp pom.beforeDebianBuild.xml pom.xml
	
Cleaning command:
	cd $HOME/tmp/reflection-ui; rm ../*reflection-ui*.*; cd -
	debuild clean
	

