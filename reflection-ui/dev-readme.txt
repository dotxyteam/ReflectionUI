DESCRIPTION
-----------
The aim of ReflectionUI is to allow to generate appropriate UIs from objects
without coding (or with very few coding).


DEVELOPER GUIDE
---------------
Since there is not enough information in objects to build a user friendly UI, 
enrichment and customization are then needed.
To achieve this goal, 2 main layers have been created:
- IInfo layer: an abstract GUI model
- Rendering layer: GUI elements layer

	IInfo layer
	-----------
	It defines an abstract GUI model that is an extended subset of the object 
	oriented paradigm: Classes are ITypeInfo objects, field are IFielInfo objects, etc.
	This model is then mainly composed of interfaces + default implementations.
	Here are the important elements:

		IFieldInfo interface
		--------------------
		This interface represents a field in the object oriented paradigm.  It then allows
		to define how a field should be represented. By default the field representation
		will be based on its type.

		IMethodInfo interface
		---------------------
		This interface represents a method in the object oriented paradigm.  It then allows
		to define how the method representation should behave. By default the method representation
		is an action button that would require parameters values and display the return value
		in a child dialog.

		ITypeInfo interface
		-------------------
		This interface represents a class in the object oriented paradigm.  It then allows
		to define how an object UI of a given class should look like and behave.
		It mainly provides UI informations about fields and methods.
		2 important interfaces are derived from ITypeInfo:

			IListTypeInfo interface
			-----------------------
			This interface allows to describe list-like objects. Various specificities are
			handled like ordering, hierarchy (trees), columns, etc. By default as much information
			as possible is extracted from the standard list-like classes (arrays, collections).
			Hierarchical and tabular features are described by the following types:

				IListStructuralInfo interface
				-----------------------------
				This is the main class describing the hierarchical and tabular structure bound to
				a IListTypeInfo instance. 

				ItemPosition class
				------------------
				This class defines a location and a path to an element in a hierarchical list (or a tree).
				The path is actually the set of informations (field value access infos, list item access infos)
				needed to retrieve or update the value held by a node. Note that the ItemPosition will also 
				allow to check if a node is read-only, its value return mode (reference or copy), etc.
				Typically an ItemPosition will have ancestor ItemPositions allowing to access all the 
				ancestor nodes of the current node.
				Remark: the ItemPosition works in conjunction with the IFieldInfo or IMethodInfo it is associated 
				with. It retrieves the node value from the value returned by the I*Info and updates the value
				that should then be committed by the I*Info.  

				IColumnInfo interface
				---------------------
				This interface allows to enrich the abstract UI model of list-like objects by
				providing multiple user-friendly (organized and formatted) views of list items.

				
			IEnumerationTypeInfo interface
			------------------------------ 
			This interface allows to define objects as being enumeration items. By default only 
			enum types are interpreted as IEnumerationTypeInfo instances.

		ReflectionUI class
		------------------
		This is the class that will build the default implementations
		of IInfo interfaces from objects. Note that it is possible to build implementations
		from other sources such as databases, etc. These default implementations will
		usually need to be customized since there is not enough informations in objects
		to build a user friendly UI.

		InfoProxyFactory class
		----------------------
		This class helps to build proxies of IInfo interfaces in order to customize the 
		default implementations.
		
	Rendering layer
	---------------
	This is the layer of the GUI elements that are created according the
	supplied IInfo instances. This layer is itself divided into the
	following components:

		Forms
		-----
		Every UI generated by this library is actually a form. This is the main
		GUI element. Forms are therefore bound to a windowing toolkit.

		Controls
		--------
		Each form is composed of field and method controls. Some
		field controls can contain sub forms so that any complex UI structure
		can be generated. Controls are therefore bound to a windowing toolkit.

		Control place holders
		--------------------
		Controls are not directly integrated in forms. They are contained in
		place holders: instances of FieldControlPlaceHolder & MethodControlPlaceHolder.
		The place holders can provide basic control features that will ease the development
		of new controls. Eg: refreshing, error display, undo management strategy, etc.
		Controls can take control of these features by implementing the IAdvancedFieldControl
		interface. Place holders will also handle common features like busy indication,
		update synchronization and delaying, etc.

		Control data layer
		------------------
		This layer contains mainly these elements: IFieldControlData & IMethodControlData.
		These interfaces represent the minimum set of informations needed by the controls
		to achieve their work (how to get/set a value, field caption, etc).These interfaces
		implementations will then act as a glue between the controls and the IInfo instances.
		These control data interfaces were separated from their IInfo counterparts to
		simplify the development of new controls. Note that this layer is not bound to
		any windowing toolkit.

		ModificationStack class
		-----------------------
		This class provides a feature that is common in GUIs: undo management.   
		Note that this class relies on the control data layer and therefore is not bound to any 
		windowing toolkit.

		Renderers
		---------
		These are some of the main components of this library. For now only one renderer
		is available: SwingRenderer. A renderer is actually a factory of GUI elements.
		It will then create control data objects, controls, forms, ModificationStack objects
		and glue them all together to provide a working UI.

	Customizations
	--------------
	The CustomizedUI class inherits from ReflectionUI and use the InfoCustomizationsFactory 
	class to support the creation of proxies of IInfo interfaces from InfoCustomizations 
	class instances. The 'custom-ui' project hosts the SwingCustomizer class that inherits
	from the CustomizedUI class and offers tools that allow to visually edit the 
	InfoCustomization class instances. Note that InfoCustomization class instances are
	persisted as XML documents.
		
		Performance considerations
		--------------------------
		The generation of customized proxies of IInfo interfaces is complex and takes time.
		The use the UIs generated from these customized proxies could have been problematic
		since there may be a great number of proxy layers that need to interact in order to
		provide a functioning UI that could have then been less reactive. To prevent this 
		issue, proxy caches are used to minimize to cost of the computation needed to rebuild 
		the	proxies.
		
		Design mode considerations
		--------------------------
		But, during the design phase, InfoCustomizations class instances are constantly 
		modified and the IInfo proxies need to be rebuilt in order to provide coherent and 
		up-to-date UIs. For this reason, the customized ITypeInfo proxies cache is cleared
		after each customization action. Also the UI components are reconfigured 
		or completely rebuilt when a structural change that cannot be incorporated is 
		detected. If this detection is not well implemented, then the customization action
		may	not produce the desired effect.		
		This detection is performed this way: each form searches for an eventual change
		in its structure (categories, lists of fields and methods). The 'equals(...)' 
		method is used on the fields for that, but it does not verify the field types
		that are calculated lazily and cached. Yet these types may change after a 
		customization action and their cached version may become obsolete. That is why
		the customized types cache must be cleared after each customization action
		and no other type cache should be used.
	
	Entity concept
	--------------
	An editor instance often allows to view/update a single object that has a specific
	reference/identity. But sometimes the editor manages over time multiple objects that
	however represent the same entity. This is typically the case with calculated field
	values. This entity concept must be and is taken into account by UIs. But it is not
	trivial: entities cannot systematically be identified by generic UI generators.
	Inspecting objects metadata is not enough. Additional information like value mode 
	(direct, calculated, ...), list item position predictability, etc, need to be provided.
	Formally an entity is identified by an invariant: its access (get/set) method that
	often depends on its parent/ancestors access method(s). 
		
		List/tree item entities
		-----------------------
		Typically, an item contained in a stable list/tree (stable according to the item 
		positions predictability) is an entity identified by its ItemPosition (that actually 
		gives access to the successive objects	and fields used in order to get/set a specific 
		item value). In an unstable	list/tree the item would rather be identified the combo 
		ItemPosition+ancestors. Note that if the parent item entity resolution fails, or if 
		both the item position is unpredictable, its value mode indirect and its equals(Object) 
		method implementation unreliable, then the item entity resolution will fail.
		
		Background validation considerations
		------------------------------------
		Generic UI entity resolution is then required for list/tree display, but also for
		validation. Indeed it should be possible to validate once a whole object model in 
		background, assign the resulting errors to the model entities, and consult afterwards
		these errors on the UI components that display the concerned entities. It would then
		be necessary to have available entity objects in order to map them to the validation
		errors. But since the development of such entity objects may be expensive, it may be 
		appropriate to first map the object values to their validation errors by using a
		key equality-based cache. It actually makes sense to map multiple equal objects to a 
		single validation error, but it could lead to inconsistencies: validation errors may 
		get lost when the equals(Object) method is not correctly implemented, or appear on
		components of valid object when the validation depends on a context. The temporary
		workaround would be to use ValidationErrorAttributionStrategy that allows to adapt
		the object model in order to prevent these issues.
		
	
	
		
		
		
		
		