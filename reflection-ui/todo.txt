- review the logging system: there are some validation 
error logs that are always displayed. They should be 
displayed only in debug mode. The rule is: if error
already displayed on the screen then log the details 
only in debug mode. 
- a field control has no way to express that it cannot
display null. Ideally if it cannot then it must be
wrapped either in a nullable control if null must be
distinctly displayed or in a non-nullable control otherwise.
Note that the "can handle null" information would be
available only after the creation of the control that 
would then fail in the current state of the API.
The only solution is then to throw a kind of 
InputRejectedException during the creation or the update
of the control. Currently a similar exception is taken into 
account during the creation of the control but not during
the update. Note that currently null will cause issues 
with ListControl and Slider maybe. Must the API be changed?
May be a control factory should be added for each type of 
control so that the capabilities of the controls would
be known before their creation, just like field control
plugins actually. For now it may be quicker/simpler to throw 
an InputRejectedException exception and handle it or
ensure that all controls support null and document
that new controls must necessarily support null. 

Supporting null
means that the control does not crash and displays a default
value (not distinct). This is actually wanted unless 
isNullValueDisticnt() returns true in which case the null 
value must be distinct.
Currently built-in controls (except enum control, polymorphic 
control and plugin controls) are systematically
considered as not being able to distinctly display null
values and plugins all declare themselves as not being able
to distinctly display it. All the controls except
ListControl support null. My bet is that for now it would
be enough to make the ListControl support null and document
all these somewhere. Update: the ListControl supports null,
then there is nothing to do (except document it).
Caution: 
Currently the non-nullable control is used when
isNullValueDistinct() returns false. Which means that it
prevents controls from encountering null and displaying a default value. 
It seems that it is not the expected behavior but fortunately
it only happens when the declared type is different from
the actual value type. Null in this case allows to pick
a more suitable control and change both the actual type
and the control later. Anyway in order to display the default
value on null it is still possible to alter the declared type.



- a field info is the specification of an object attribute
that must be displayed on the screen. When displaying an
object attribute it is sometimes necessary to create a
new value for the attribute and how to do that must be
specified in the field info. The fieldInfo.type.contructors
should give this information. Most of the time it is enough
except for the creation of implicit list items: the parent
object is required while creating items. The problem is
that the field info cannot hold a reference to the owner object
of the attribute that it is describing. Why: because by
design the specification of how to display an object on the screen
(type info) must be known before encountering any possible
variation of the object (instances). Why: because a UI
has limited capabilities by nature: it cannot adapt to
every possible set of values since it is not intelligent
and we also need it to be predictable, to inform us about
all the possible values, the current one, and allow us to 
choose another one. Then the domain of values (the type) 
must always be known. But it still does not imply that
the instance should not be referenced by its type info.




- the ui thread is for actions that need to update the ui.
An action can start from the ui and end by modifying it.
In the meantime the action can run in a background thread
to allow the ui to display a feedback. Then the scheme is 
ui-trigger, ui-busy-indication, background-processing and 
then ui-update. Sometimes during the background processing
some user input may be required. Then the ui thread will 
be temporarilry solicited. These are the only possible schemes.
Then
	. when to invoke busy indication: when we are in the ui thread
	and we are not updating the ui
	. when to invoke the ui thread: when we are not in the ui thread 
	and we update the ui (or when we require user input).
	. when to run the task directly: otherwise
- check why ReschedulableTask threads cannot be single. Normally they can
since they do not reference the ReschedulableTask object.
- Some objects and their editor components are never garbage collected
when their editors are disposed. Find a solution. Check static caches. 
- JFrames (maybe JDialog too) do not get garbaged. They are intended
to be reused. SwingRenderer always create new windows( never reuse).
It must be possible to use a pool of windows.
- AbstractEditorFormBuilder.refreshEditorFormOnModification(Form) may
be obsolete since all fields (sub-forms, ..) are refreshed on any
modification. Check and correct.
- method result field: the name will be duplicate if there are
2 methods with same name but different signatures.
- undo/redo title often empty. See Calculator example.
- add a customization option for type icon based of field value.
- IMethodInfo.validateParameters() never overriden on proxies. Check.
- check that (may be automitically and constantly) that
typeInfo.source == source.typeInfo
- MembersCustomizationsFactory.transformMethods() potential issue: the signature 
of the transformed method often changes during the transformation but not the
method customization and this may cause issues in proxies that must deal with
this inconsistency.
- Find a strict rule to conveniently order MembersCustomizationsFactory
transformers. 
Hints: 
	. Should new generated members inherit customizations and then change 
	"silently" while the source member is being modified ?
	. Should the order of customization options in the customization tools
	be respected ?
- ParameterizedFieldsMethodInfo undoJob is always created even if it cannot
be executed mostly because the method cannot. Find a way to enable the undo
button since it will not work.
- add "virtual composed list field" customization option that would use 
ImplicitListFieldInfo.
- it may be better to not have dependencies at all typically for
swing-testing-toolkit that would be more compatible with projects 
- lastFilePath should be saved by file type or ...
- allow to select value options field.
Note that it is difficult because virtual fields and their type are discovered at
runtime after the customizations application. Then there is no way, unless we
are given a reference to the customized ITypeInfo, to know which fields are
available when building the customization tools. It may be a solution to 
cache the ITypeInfos maybe in the SwingCustomizer each time a form is created
and customizations are enabled for instance. But it implies that the
required ITypeInfo and therefore the candidate value options fields may not be 
available preventing their selection. Maybe an explicit error message could be
displayed in this case.
- Use html control to display online help ???
- date(-time) picker controls remove selection on delayed commit.
- list customization (more options/item/open item shared type) does not allow
to view item type "Object". One may want to add sub-types to the Object type.
Think about it. Note that the type can be accessed from the customization
controller.
- modifying a customization makes leave the current form category. Fix.
- InfoCustomizations.getInfosOrderAfterMove() returns list of names
for methods. SHould probably be list of method signatures. Check.
- sub-form of transient fields do not contain transient fields.
- not sure return value mode is meaningful anymore.
Eg: fields always gets refreshed on any update whether they are calculated
or not. Think about it. 
- factories get constantly recreated uselessly from CustomizedUI.
There's then a room for optimization.
- DefaultParameterInfo.getDefaultValue(Object) return a value for primitive
types. Not sure it is a good idea to provide a default value without the
user acceptance.
- AbstractEditorFormBuilder.getEncapsulatedFieldNonSpecificTypeSource():
the type source should be non-specific but it often is.
Check if it is really necessary that it be non-specific and adjust.
- BufferedItemPosition.getSubItemPosition(int) is required to clear its
result buffer because the clone() method copies it. Maybe it would be better
to have a custom clone() method (not the built-in one).
- StandardMapAsListTypeInfo.isOrdered(): may need to always return true and
be able to adjust from the customizations since everything is possible.
Maybe the return value can be set for standard implementations by 
isAssignableFrom() should be avoided since the actual implementation can
do whatever it wants.
- In maps when the key changes then the entry is often moved in the list view
but the selection is not updated 
- ReflectionUIUtils.(setFieldValue|invokeMethod)ThroughModificationStack():
when the ModificationStack.apply() fails then the error is caught and
ModificationStack.invalidate() is called and fails too (often) because
of the same commitModification issue. Find a solution to not cause the 
same error twice.
- DialogAccessControl.openDialog(Component) calls refreshUI(). Is this really needed
since when an impact is detected the whole dialog gets refreshed ?
- Form.recreateControlPlaceHoldersIfNeeded() should not create controls (only place holders)
since they may be dismissed.
- ReflectionUIUtils.setValueThroughModificationStack() and SwingRendererUtils.handleErrors()
are directly called by controls though they should only be called by FieldControlPlaceHolders. 
Check...
- add customization option for list method shortcut icon
or reuse the icon specified for the related method and eventually allow to override it
- add an option to allow a method to reset the modification stack (forget()).
Useful for methods like "loadFile()", "newProject()", etc.
This option would be handled here: ReflectionUIUtils.invokeMethodThroughModificationStack()
- there is a space before ListControl items because of setShowsRootHandles(true).
But setting false prevents from expanding a node to see its children.
Need to find another solution.
- maybe allow to execute a method upon list item selection. 
The method would take an item as parameter.
- ImageView: allow to associate mouse events to methods having pixel location parameters 
(int x, int y, ...). Additionnal parameters could be asked before performing the action.
Mutiple methods associated with the same event would trigger a contextual menu
allowing to choose between them. 
- list control actions validity should depend on the root list or can change
according to the list?
- should RUIUtils.NULL_JOB be used to disconnect a field from the modif stack???
- SliderPlugin: the value is formatted. OK or not???
- There is a problem with dialogs cancel button that reverts
everything since now modification stack size is limited.
Think about it. Infinite stack may be necessary
- Can not disconnect a field from the modification stack, 
there is probably the same issue with methods, check.
Check also IModif.NULL_MODIF.
- what are the effects of limiting modification stack size???
  . Some dialog cancel buttons will not work well
- allow to disable method parameters memory
- allow to use modif stack actions as methods:
	. the problem is that the customizations modifies the
	iinfos that have access to the user objects only. The
	modif stack is at another level, it have access to the 
	iinfos and the gui controls have access to it. 
- foreground =) text ???
- radio button icons
- scrollbar not showing when list control contains 1 long column
- hidden modification stacks should not store any modification
- allow to specify field target for method modification (will allow to undo method modifications)  
- allow to clean type customizations (remove renamed/removed field/method customizations).
It would be a temporary solution since it should be done automatically.
- the controls should not rely on the place holder or the form 
to trigger refresh. Also the form should not trigger uselessly 
the refresh on the field control that triggered the update that 
triggered the form refresh. 
- pass object as param to 
	. ITypeInfo.getMenuModel()
	. new MethodmenuItem()
- menu model contains swing classes though it is not not good and not even needed.
	. standard menus (undo, help, ...) can be created by generating related methods
	from the ITypeInfo
	. the action menu item will only need to expose its IMethodInfo so that the renderer
	will be responsible of all presentation stuff
	. file menus settings will just be file control settings 
	. other menu items that act on the rendered stuff (windows, ...)  will then inherit
	from a special super class that give them access to the the rendered stuff with the 
	agreement of the renderer 
- test commit author 3
- add to ITypeInfo:
	- IFieldControlPlugin getControlPlugin();	
	- Object getControlPluginConfiguration();
- cannot specify null param default value
- undo/redo/etc menu tooltips absent
- optimize data update delay: not needed systematically
- improve delayed update process: extend the sleep duration on alreadly delaying schedule 
- add a proxy factory to check type specifities identifiers
- alternate (with checkbox above) nullable control plugin 
or change the nullable control depending on sub control showsCaptions() 
- StandardMapAsList: pass key and value types as typeInfos not java classes????
- IModification.getTarget() is useless. It was only for getting modification
title. I think it was created for list dynamic actions. It seems obsolete now.
May need to remove.
- list control does not handle null values. then it does not allow
to edit sub lists when they are null => NORMAL. But it is difficult
as a developer to understand that the sub list is sometimes editable
sometimes not. Find a solution. 
- allow to specify global gui infos (Ex: reflectionUI.getGlobalInfo
	. defaults (background/foreground color, ...)
	. buttons background image/color and foreground color
	. windows background (color and/or image)
	. window decorations (system, custom, ...)
	. ...
- allow to specify form background color
- allow to disable the window scroll pane ??? 
- geometric attributes are merged with behavioral attributes 
- refresh recreates many many controls for uselessly: fix it ???
 may not be serious since it happens only when refreshStructure=true
- SlaveModifStack.exclusiveLinkWithParent: there must be a better way to design it 
- ModifStack.forget() should not forward an invalidation. It is not a reflection of
the object state. It is a choice made by the user that does not delete but hides   
all the memories about what happened to the object. Also note that loading an object
state from a file can be easily reverted by saving the object state before in a 
memory stream. 
- IControl*Input should be merged with I*ControlData
- modificationsTarget must be are just used to get
the name of the member involved in the modification.
It should be "fieldCaption" & "methodCaption" only 
- null control can disappear when form layout is horizontal
- add website checks
- in this context of chained transformations values origin should be traceable
in case of inconsistency???
- ListControl issue: can make tree table control larger but not smaller
to its original length
- allow to export/import to/from clipboard
- allow menu shortcuts/accelerators
- update website:
	* screenshots
	* examples 
	* ...
	* update github sites
- new controls:
	. dateChooser
- display null equivalence greyed ???
- remove method return value specificities ???
- parameters should get their customizations from
	parameterAsField customizations ???
- listControl: allow to edit multiple items at the same time
- allow to disable copy/cut/paste on lists
- add ITypeInfo.equals() ???
	=> not urgent at first sight
- what was decided about valiation of controls with no caption ???
- indent toString()s ???
- reflectionUI is often excluded from hashCode() and equals()
	=> justified ?
- dialog/panel creation is sometimes slow but no busy dialog shown
	<= multiple small showBusyDialogWHile() calls are done
	=> find a way to show the busy dialog anyway
. allow to execute dynamic actions or change dynamic properties on 
multiple nodes
- write hashCode() & equals() of some inner classes where the IDE
could not generate them
- Type params must be get from the IField/MethodInfo, not ITypeInfo
just like in the Java spec.
	. add IFieldInfo.getTypeParameters()
	https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/reflect/TypeUtils.html
	. maybe take a shortcut and implement it in a next future version
- ReflectionUI parameter is often useless. Check
- polymorphiControl:
	. what if there is only 1 subtype. use polymorphic control anyway?
- cleaning for end-developer:
	. add ReflectionUIError explicit messages
- remove IListTypeInfo.getObjectSpecificItemConstructors???
- allow to sort list view
- update ScreenShots
- update Example
- Fix all the tests
- MultipleFieldAsList with only 1 item???
- add class MetodSignature???
- update translatable strings


